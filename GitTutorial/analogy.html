---
title: Getting Git for Beginners | Analogy
layout: default
---
<span class="part">Part 1</span>

<h2>The Journey: Write a book</h2>

<p>You’ve decided to follow your dream and write a book. You plan for an
  epic novelization on the life of the humble cow. It will be grand. It
  will be sweeping. It will be moooving.</p>

<h3>Working Directory</h3>

<p>Your first step is to create a new folder for your project called
  MyProject. All of your files will go in this folder. You'll call this
  your <span class="terms">working directory</span>. (For the intents and
  purposes of this tutorial, directory and folder mean the same thing. They
  are synonyms.)</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/make-new-folder.png" alt="Screenshot showing how to create a new folder on MacOS" />
  <figcaption>Create a new folder</figcaption>
</figure>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/MyProject-folder.png" alt="Screenshot showing the new MyProject folder" />
  <figcaption>MyProject folder</figcaption>
</figure>

<p>Use Microsoft Word, VS Code, or any other application you want to
  create files. Or copy images, videos, whatever.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/chapter1.png" alt="Screenshot of MS Word document" />
  <figcaption>Word Processor</figcaption>
</figure>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/code-editor.png" alt="Screenshot of VS Code editing a text file" />
  <figcaption>Code Editor</figcaption>
</figure>

<p>Let’s add a picture of a fluffy bunny. Just for fun. Every good
  project needs a fluffy bunny. You’ll work it into the story somehow.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/fluffy-bunny.jpg" alt="A photo of a cute, little, brown, fluffy bunny" />
  <figcaption>Fluffy Bunny</figcaption>
</figure>

<p>So now your folder looks like this:</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/folder.png" alt="Screenshot of the contents of the folder, three files created above" />
  <figcaption>Folder</figcaption>
</figure>

<p>A few days pass, and you have written quite a bit of chapter 1, but
  now tragedy strikes. You realize that you deleted a page worth of text
  that should really be in the book. You really wish you had a copy of the
  document from two days ago. But there's no time machine, and the
  program’s undo function doesn’t go back that far. Even if it did, it
  would delete everything you wrote after you deleted the page. You decide
  to do something going forward.</p>

<p>You reckon that life would be good, and mistakes would be recoverable,
  if you just had a snapshot of all your work at the end of each work
  session. Something like the “undo” ability of your word processor, but
  for all of your files. You imagine a system that would account for any
  changes in any file, effectively making a backup or snapshot of your
  folder at any time you desire. So, being the inventive and creative
  type that you are, you are going to do something about it and take a
  snapshot of your documents at the end of each day, so this never
  happens again.</p>

<h3>Snapshots of the Past</h3>

<p>You start by making a <span class="terms">snapshots</span> folder
  where you will put your snapshots. You'll keep things here so that you
  don't have a mess of files cluttering up your main project folder. A
  snapshot will be a copy of all of the files in the project folder, or the
  working directory, at a specific point in time.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/snapshot-folder.png" alt="Screenshot of the Finder app showing the snapshot folder" />
  <figcaption>Snapshot Folder</figcaption>
</figure>

<p>As you do this, you realize, it might be even better to have each
  snapshot go into a folder named with the date and timestamp in case you
  have multiple snapshots in a day. You decide that each snapshot should
  contain just a single change. You can imagine a scenario where you spend
  all day working on 5 different aspects of the project and commit all of
  those changes into one snapshot. Then later, you realize you want to
  revert just one of those changes. Since all 5 are in the same snapshot,
  all 5 changes are reverted, instead of just the one. So, to avert such an
  issue, you decide to make each snapshot contain a single concise change
  or chunk of work. The snapshot may contain changes to several files, but
  they all relate to a single topic or purpose. For example, you can add a
  chapter and an illustration to go along with it.</p>

<p><span class="software"> If you think about coding a software project,
    a snapshot would be a concise, individual feature, or a bug fix, or even
    adding a single function and the code to test the function.</span></p>

<p>Since this is a reflection of what Git does, I’ll just interlude here
  to say that a snapshot in Git speak is called a <span
        class="terms">commit</span>; you're committing the snapshot to the
  snapshots folder, or as Git calls it, the <span
        class="terms">repository</span>. A repository acts as the history of
  your project’s files. It is a record of the changes, as recorded by you,
  every time you take a snapshot (or commit) of the working directory.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/snapshot-dated-folders.png" alt="Screenshot of the Finder app showing the dated sub-folders in the snapshot folder" />
  <figcaption>Snapshot folder with dated sub-folders</figcaption>
</figure>

<h3>Staging Area, the Index</h3>

<p>You work like this for a while. Maybe a few days. And the system is
  working great. You feel confident each day because you can start working
  without fear of losing anything you created in previous days. You have a
  snapshot of every change you’ve made.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/chapter3.png" alt="Screenshot of MS Word showing the text of chapter 3 of the book" />
  <figcaption>Chapter 3</figcaption>
</figure>

<div class="hidden-text">
  <p>Chapter 3 text</p>
  <p>Full of wonder at the sites in the wonderful field, Sheila braced her
    bovine self for the fabulous feast that awaited her. Never had she
    encountered such a wide variety of green grass, white weeds, and hazel
    hay. This would be a great day indeed.</p>

  <p>The first thought that struck Sheila, after the delightful thought of
    devouring the field for days, was that she ought to return quickly to the
    herd and tell Carla, Olivia, Wanda and the others. Would this be selfish
    to keep the location of this field to herself? Could cows be selfish?
    With that last question, Sheila promptly forgot the others and started in
    on the munching and crunching.</p>

  <p>It was not until several hours and several chewed cuds later that she
    realized it was getting dark. Would she be able to find her way back to
    the herd? Sheila rose slowly to her hooves and looked around. Now, which
    way was it back to the herd?</p>
</div>

<p>But today, after working for several hours on chapter 3, you remember
  something vital for chapter 1. How can you take a snapshot of the change
  to chapter 1 without adding all of the incomplete changes to chapter
  3?</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/chapter1-changes.png" alt="Screenshot of MS Word showing changes to chapter 1" />
  <figcaption>Chapter 1 changes</figcaption>
</figure>

<div class="hidden-text">
  <p>Chapter 1 text</p>
  <p>In the beginning, it was a dark and stormy night.</p>

  <p>As the cowardly cattle began their meandering march to the
    burned-out barn, a sudden flash of lightning illuminated the nascent
    night sky, the high hills and fallow fields, and the rutted route
    before the brainless bovine.</p>
</div>

<p><span class="software"> If you are a software developer creating a new
    feature in your software or website, what do you do if you find a bug in
    the code while working on a new feature? How can you quickly fix the bug,
    commit the change to fix the bug, but not incorporate the incomplete
    changes to the feature?</span></p>

<p>You decide to make a folder in the snapshot directory (so it doesn’t
  clutter the working directory) for staging your snapshots. You will add
  to the staging folder only the changed files you want in the snapshot.
  Then you will commit only those files in the staging area into a new
  snapshot.</p>

<p>So, first, you make a new folder in the snapshots folder called <span
        class="terms">staging</span>. Git also calls this staging folder the
  <span class="terms">index</span>.
</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/staging-folder.png" alt="Screenshot of Finder app showing the staging folder" />
  <figcaption>Staging Folder</figcaption>
</figure>

<p>Now you can add just the changed chapter 1 file to the staging folder,
  then make the snapshot of the staging folder. This way, you can keep
  certain unwanted changes from cluttering up your snapshots.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/staged-file.png" alt="Screenshot of Finder app showing the file in the staging folder" />
  <figcaption>Staged File</figcaption>
</figure>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/stage-to-snapshot.png" alt="Screenshot of Finder app showing the file in the new snapshot folder" />
  <figcaption>Staged File to Snapshot Folder</figcaption>
</figure>

<p>But, why would you add the staging folder, when you can just copy the
  files you want from the project folder directly into a new snapshot
  folder? In reality, it is an unnecessary step for the process you have
  now, but keep in mind that you are mimicking the Git software. Using a
  staging folder will make it much easier to have software do this step for
  you at a later time. In the Git software, the staging folder, or index,
  points to the latest commit. When you change files in the working
  directory, Git can see the differences from the last commit and the
  current state of files in the working directory. This is really handy for
  showing exactly what has changed in a specific file or directory.</p>

<h3>Alternative Timelines</h3>

<p>This process works really great, and you plug along for days before
  running into the next issue. As you continue to polish chapter 3, you
  have a brilliant idea that may or may not work with the current plot-line
  you have going with the book. You don’t want to start a new project, or
  clutter your current working directory. What can you do?</p>

<p>You take a break from this problem and look over your map of the New
  York Subway system as you think of your upcoming trip. This gets your
  brain spinning about a possible solution for your content management
  problem. The iconic map of the subway is a series of connected lines that
  branch off and reconnect, and there are many dots representing stations
  on each rail line.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/1000px-NYC_subway-4D.png" alt="Image of the New York City Subway Map, many colored lines over a map of NYC" />
  <figcaption>New York City Subway Map</figcaption>
</figure>

<p>As you think about it, you realize that one subway line is like a
  timeline of your project’s history. Each of the subway stops is like a
  snapshot. The different subway lines are like alternate timelines, or
  branches with different possible snapshots. Is there a way to branch off
  of your main project “line”, make some new files, create some alternative
  ideas, but come back to the main line when needed, or even merge the
  ideas in the alternative lines back into the main line?</p>

<p><span class="software"> In writing software, this makes even more
    sense. If you find a bug in your code, you can take the last snapshot,
    fix the errors, then put the fixed code as the next commit in the main
    line.</span></p>

<p>The current status with your project and the five snapshots you
  already have might look something like this:</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/commit-map.jpg" alt="A blue line with white dots on it, and images of the snapshot folders pointing to the white dots" />
  <figcaption>Map of recent commits</figcaption>
</figure>

<p>The blue line represents the “timeline” of your project, and each
  circle represents a snapshot, as it goes in chronological order from left
  to right.</p>

<p>Now you can easily imagine a separate line branching off of the last
  snapshot to form a new line. You can then make further edits and
  snapshots on the new line, and the main line without mixing the two. But
  then when everything on the new line looks good, it can be merged back
  into the main line.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/merging-lines.png" alt="A blue line with white dots, from one dot a green line emerges, with it's own white dots, and returns to a white dot on the blue line 3 dots away" />
  <figcaption>Merging Lines</figcaption>
</figure>

<p>That’s a great analogy, but how can this work in real life? How can
  you tell the “genealogy” of a snapshot? Which comes before, and which
  comes after? Upon further reflection, you decide the easiest way to
  manage this is to create a file in the snapshot folder with information
  that designates which snapshot is it’s “parent”. This is as simple as
  typing something like</p>

<pre><code>
      parent: [folder name of parent snapshot]

      </code></pre>

<p>You realize that this info file in the snapshot can do more than tell
  you which snapshot is the parent. You can also add a short “title” for
  the snapshot and give a description of why the change was made. As you
  think about the future of your book, you realize your editor is also
  going to be looking at these files, and will want to make suggestions.
  Perhaps branching will be super beneficial here, too. Your editor can
  create a branch for the edits, and then you can merge them in if you
  like. To better keep track of who suggested a change, you decide to also
  include the author and their email address in the info file.</p>

<p>So, inside each snapshot folder, you now put a new file called
  <code>info.txt</code> and it will contain the following information:
</p>

<pre><code>
      parent: <folder name of the ‘parent’ snapshot>
      author: <first and last name of person who made the snapshot>
      email: <author’s email address>
      date: <date the commit was made>
      message: <a succinct title for the submit, with a possible more lengthy description>
      </code></pre>

<p>It might look like this:</p>

<pre><code>
      parent: 2021-02-08-213242
      author: Jillian Jiggs
      email: makerofpigs@jiggs.com
      date: 2021-02-09-143342
      message: Adds plot line for Martha the moose
      </code></pre>

<h3>Reducing File Count</h3>

<p>As you implement this new info.txt file, you realize that if each
  snapshot is pointing back to its “parent” that you no longer need to copy
  all of the files from snapshot to snapshot. You really only need to
  include the files that have changed since the last snapshot. This is good
  news for your filesystem, as you were starting to get hundreds of files,
  and if you start adding more images and videos (because this is a
  futuristic, multimedia type of book), it will be great to only have one
  copy of the file in the filesystem.</p>

<h3>Collaborating with others</h3>

<p>Branches become even more powerful when you start collaborating with
  others. Writing a book solo is hard, so you enlist the help of friends
  and family to proof-read and edit your chapters. With your repo all set
  up, you can easily hand out chapters and have people read and comment on
  the document. You create a new branch for each edit that comes back, then
  review, make changes, and when satisfied you merge those changes back
  into your main timeline.</p>

<p>Here it is important to get a broad view of what you are creating.
  Each of your snapshots are like a point on a timeline. You have a main
  timeline where the last commit on this line is the current, up-to-date,
  best version of what you have.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/branches.png" alt="A very long blue line with 20 white dots. Several differently colored lines emerge from white dots on the blue line, span several dots, then connect back to the blue line on a white dot" />
  <figcaption>Branches visualization</figcaption>
</figure>

<p>If an editor, friend or relation reads your chapter and suggests some
  changes, you can easily merge those changes back into your main timeline,
  even if you have made changes since then.</p>

<p>You can now effortlessly give your book chapters to others to read,
  then import their changes back into your system.</p>

<figure>
  <img src="/{{ site.baseurl }}/assets/images/edits-branch.png" alt="Similar to the previous image, but one new line does not reconnect to the blue line" />
  <figcaption>Branch with edits</figcaption>
</figure>

<p><span class="software"> In the software development world, you could
    even share the whole working directory with collaborators. This would
    allow them to see the entire history of the code base, perhaps giving
    them insight into how and why you chose to code functionality in a
    certain way. You could even host the working directory on an accessible
    server so collaborators can pull the most recent version of the code from
    the server to their computer. When they are done making changes, they can
    push their code back to the server.</span></p>



<a class="button" href="git-compared.html">Next: Git Compared</a>